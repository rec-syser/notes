# JAVA 并发编程

## 基础知识

### 缓存一致性协议

![image-20200901153542437](java_concurrency.assets/image-20200901153542437.png)

![image-20200901155550739](java_concurrency.assets/image-20200901155550739.png)

1. 如果两个cpu同时对缓存中相同的数据进行了操作，并且想要保存到主存中，这样在一个指令周期内会对两个cpu的指令进行裁决，决定执行那个cpu的指令并保存相应数据。
2. 缓存行：CPU缓存的最小存储单元
3. 机械硬盘的最小存储单元：簇
4. 总线锁和缓存一致性是锁的粒度不同
5. 什么情况下缓存一致性协议会失效：
   1. 缓存行失效：存储变量的存储长度大于缓存行的长度。这时候只能加总线锁
   2. CPU本身不支持缓存一致性协议

### JAVA线程

#### 线程的五种状态

![image-20200902093859468](java_concurrency.assets/image-20200902093859468.png)

1. 进程是系统分配资源的基本单位，线程是cpu调度的基本单位
2. 使用用户级线程可以避免过度创建线程
3. 用户级线程和内核级线程的理解：https://juejin.im/post/6844903962504593421 
4. 上下文切换时需要将当前运行结束的时间片的线程数据（指令 程序指针 中间数据）刷新到内核栈中（linux Tss 任务状态断）
5. 为什么要用到并发：
   1. 充分利用多核CPU的计算能力
   2. 方便进行业务拆分，提升应用性能
6. 并发产生的问题：
   1. 高并发场景下，导致频繁的上下文切换
   2. 临界区县城安全问题，容易出现死锁
      1. java 排查死锁的工具 jsp

### JMM java 内存模型  --- java 线程内存模型

#### 理解

<img src="java_concurrency.assets/image-20200902093028491.png" alt="image-20200902093028491" style="zoom:67%;" />

<img src="java_concurrency.assets/image-20200902101826432.png" alt="image-20200902101826432" style="zoom:67%;" />

1. JMM与JVM内存区域的划分是不同的概念层次，应该加JMM理解为是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式
   1. JVM围绕原子性、有序性、可见性展开
2. JVM内存区域的划分是逻辑上划分，操作的是逻辑空间
3. 图中 主内存 是硬件环境下的内存条的抽象
4. 工作内存是cpu缓存的抽象
5. 这种抽象是为了屏蔽底层的操作系统的不同，实现兼容

#### 问题

1. 既然CPU有MESI缓存一致性协议，为什么JMM还需要volatile 关键字？https://juejin.im/post/6847902216255356936 没有详细看完

